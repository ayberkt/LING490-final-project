{-# LANGUAGE UnicodeSyntax #-}

module Main where

import           Data.Array           (Array, listArray)
import           Data.HMM             (HMM (..), viterbi)
import qualified Data.Map             as M
import           Data.List            (intercalate)
import           Data.Number.LogFloat
import           Parse
import           Prelude              hiding (putStr, words, lines)
import           System.Directory
-- import           System.IO (putStr)
import           Text.XML.HXT.Core

type ‚Ñ§ = Int      -- The integer type `Int` will be denoted by ‚Ñ§.
type ‚Ñö = Double   -- The double type will be denoted by ‚Ñö.
type ùìõ = LogFloat -- Log-domain numbers to prevent underflow.

Œµ ‚à∑ Double
Œµ = encodeFloat 1 $ fst  r - ds
  where r  = floatRange (0.1 :: Double)
        ds = floatDigits (0.1 :: Double)

sample‚ÇÅ ‚à∑ Array Int String
sample‚ÇÅ = listArray (0, 4) [ "g√∂zleri"
                           , "kor"
                           , "gibi"
                           , "yanƒ±yordu"
                           , "."]

sample‚ÇÇ ‚à∑ Array Int String
sample‚ÇÇ = listArray (0, 3) [ "adam"
                           , "yine"
                           , "geldi"
                           , "."
                           ]

sample‚ÇÉ ‚à∑ Array Int String
sample‚ÇÉ = listArray (0, 4) [ "g√ºzel"
                           , "kƒ±z"
                           , "mutlu"
                           , "g√∂z√ºk√ºyordu"
                           , "."]

sample‚ÇÑ ‚à∑ Array Int String
sample‚ÇÑ   = listArray (0, 5) [ "renksiz"
                             , "ye≈üil"
                             , "fikirler"
                             , "sessizce"
                             , "uyuyor"
                             , "."
                             ]

sample‚ÇÖ ‚à∑ Array Int String
sample‚ÇÖ   = listArray (0, 3) [ "dostlar"
                             , "beni"
                             , "hatƒ±rlasƒ±n"
                             , "."
                             ]

sample‚ÇÜ ‚à∑ Array Int String
sample‚ÇÜ = listArray (0, 25) [ "Cebren"
                            , "ve"
                            , "hile"
                            , "ile"
                            , "aziz"
                            , "vatanƒ±n"
                            , ","
                            , "b√ºt√ºn"
                            , "kaleleri"
                            , "zaptedilmi≈ü"
                            , "b√ºt√ºn"
                            , "tersanelerine"
                            , "girilmi≈ü"
                            , ","
                            , "b√ºt√ºn"
                            ,"ordularƒ±"
                            ,"daƒüƒ±tƒ±lmƒ±≈ü"
                            , "ve"
                            , "memleketin"
                            ,"her"
                            ,"k√∂≈üesi"
                            ,"bilfiil"
                            ,"i≈ügal"
                            ,"edilmi≈ü"
                            ,"olabilir"
                            ,"."
                            ]

pretty ‚à∑ Array Int String ‚Üí [POS] ‚Üí IO ()
pretty ws ps = let lines = (\n ‚Üí replicate n '-') <$> (length <$> ws)
                   align ‚à∑ String ‚Üí String ‚Üí String
                   align w t = let
                     n      = max 0 (length w - (length t)) `div` 2
                     spaces = replicate n ' '
                     in spaces ++ t ++ spaces
                   wsList   = foldr (:) [] ws
                   pStrings = map show ps
               in do putStrLn $ intercalate " " wsList
                     putStrLn $ foldr (++) " "   $ (++ " ") <$> lines
                     putStrLn $ intercalate "  " $
                       zipWith align wsList pStrings

table ‚à∑ Array Int String ‚Üí [POS] ‚Üí String
table ws ps = let makeItem w = "<th align=\"center\">" ++ w ++ "</th>"
                  makeRow xs = "<tr>" ++ concat (map makeItem xs) ++ "</tr>"
                  wRow = makeRow $ foldr (:) [] ws
                  pRow = makeRow $ map show ps
              in    "<html><table>"
                 ++ wRow
                 ++ pRow
                 ++ "</table></html>"

freqMap ‚à∑ Ord a ‚áí [a] ‚Üí M.Map a ‚Ñ§
freqMap unigrams = populate M.empty unigrams
  where populate ‚à∑ Ord a ‚áí M.Map a ‚Ñ§ ‚Üí [a] ‚Üí M.Map a ‚Ñ§
        populate m [] = m
        populate m (x:xs) = let freq = (M.findWithDefault 0 x m) ‚à∑ ‚Ñ§
                            in populate (M.insert x (freq + 1) m) xs

--  | Takes in a tuple (x, y) (i.e., a bigram), and takes in two frequency maps
--    c‚ÇÅ and c‚ÇÇ, c‚ÇÅ for counting all the occurrences of x and the other for
--    counting the number of bigrams.
probability ‚à∑ (Ord a, Ord b) ‚áí (a, b) ‚Üí M.Map a ‚Ñ§ ‚Üí M.Map (a, b) ‚Ñ§ ‚Üí ùìõ
probability (x, y) c‚ÇÅ c‚ÇÇ = if xCount == 0 || yCount == 0
                           then logFloat Œµ
                           else (logFloat yCount) / (logFloat xCount)
  where yCount = fromIntegral (M.findWithDefault 0 (x, y) c‚ÇÇ) ‚à∑ ‚Ñö
        xCount = fromIntegral (M.findWithDefault 0 x c‚ÇÅ) ‚à∑ ‚Ñö

main ‚à∑ IO ()
main = do
  files ‚Üê getDirectoryContents "tb_uni"
  let fileNames = drop 2 . take 1500 $ map ("tb_uni/" ++) files
  pairList ‚Üê mapM runX $ map getWords fileNames
  let taggedWordsList  = map parseTupleList pairList
      taggedWords      = concat taggedWordsList
      (ws, ts)         = unzip taggedWords
      -- For computing the probability of word-tag pair.
      taggedWordFreqs  = freqMap taggedWords
      wordFreqs        = freqMap ws
      tagFreqs         = freqMap ts
      -- For computing the probability of tag bigram
      tagBigrams       = [(ts !! i, ts !! (i+1)) | i ‚Üê [0 .. (length ts)-2]]
      tagBigramFreqs   = freqMap tagBigrams
      -- We will use these to create our HMM.
      transFn s‚ÇÅ s‚ÇÇ     = probability (s‚ÇÅ, s‚ÇÇ) tagFreqs tagBigramFreqs
      outFn s e        = probability (e, s) wordFreqs taggedWordFreqs
      initStatesFreqs  = freqMap  $ map (head . map snd) taggedWordsList
      initProbFn s     = let count  = M.findWithDefault 0 s initStatesFreqs
                             count' = fromIntegral count
                             n      = fromIntegral $ length taggedWordsList
                         in logFloat $ count' / n
      possibleTags     = [Noun .. Unknown]
      newHMM           = HMM { states      = possibleTags ‚à∑ [POS]
                             , events      = ws ‚à∑ [String]
                             , initProbs   = initProbFn
                             , transMatrix = transFn
                             , outMatrix   = outFn}
  writeFile "model.hmm" (show newHMM)
  -- putStrLn "Creating the model..."
  putStrLn $ table sample‚ÇÜ $ viterbi newHMM sample‚ÇÜ
  -- putStr "\n"
  -- pretty sample‚ÇÇ $ viterbi newHMM sample‚ÇÇ
  -- putStr "\n"
  -- pretty sample‚ÇÉ $ viterbi newHMM sample‚ÇÉ
  -- putStr "\n"
  -- pretty sample‚ÇÑ $ viterbi newHMM sample‚ÇÑ
  -- putStr "\n"
  -- pretty sample‚ÇÖ $ viterbi newHMM sample‚ÇÖ
  -- putStr "\n"
  -- pretty sample‚ÇÜ $ viterbi newHMM sample‚ÇÜ
